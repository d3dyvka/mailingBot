# Документ Требований

## Введение

Telegram Mailer MacOS App - это нативное MacOS приложение для массовой рассылки сообщений в Telegram через Telethon API. Приложение упаковывает существующий Python-скрипт в standalone .app bundle с графическим интерфейсом, позволяя пользователям запускать рассылки двойным кликом без необходимости работы с терминалом или установки зависимостей.

## Глоссарий

- **App_Bundle**: Нативный формат приложения MacOS (.app), содержащий исполняемый файл, ресурсы и метаданные
- **Telethon_Client**: Клиент для работы с Telegram API через библиотеку Telethon
- **Session_File**: Файл, хранящий данные аутентификации Telegram для повторного использования
- **Progress_Tracker**: Компонент, отслеживающий состояние рассылки (какие пользователи получили сообщения)
- **Config_Manager**: Компонент для управления конфигурацией приложения (API ключи, настройки)
- **GUI**: Графический интерфейс пользователя
- **Batch**: Группа сообщений, отправляемых за один цикл (18 сообщений)
- **FloodWait**: Ограничение Telegram API на частоту запросов
- **Universal_Binary**: Исполняемый файл, поддерживающий как Intel, так и Apple Silicon процессоры
- **Text_Editor**: Встроенный текстовый редактор для создания и форматирования сообщений
- **Error_Logger**: Компонент для автоматического логирования ошибок в файл errors.txt
- **Delay_Calculator**: Компонент для расчета оптимальных задержек между батчами на основе даты окончания

## Требования

### Требование 1: Упаковка Приложения

**User Story:** Как пользователь MacOS, я хочу запускать приложение двойным кликом по .app файлу, чтобы мне не нужно было использовать терминал или устанавливать зависимости Python.

#### Критерии Приемки

1. App_Bundle ДОЛЖЕН содержать автономную среду выполнения Python со всеми необходимыми зависимостями
2. КОГДА пользователь дважды кликает по .app файлу, App_Bundle ДОЛЖЕН запустить GUI без требования взаимодействия с терминалом
3. App_Bundle ДОЛЖЕН поддерживать архитектуры Intel и Apple Silicon как Universal_Binary
4. App_Bundle ДОЛЖЕН включать все необходимые библиотеки Python (telethon, asyncio и GUI фреймворк)
5. App_Bundle ДОЛЖЕН быть подписан кодом для совместимости с MacOS Gatekeeper
6. App_Bundle ДОЛЖЕН иметь корректный Info.plist с метаданными приложения и разрешениями

### Требование 2: Управление Конфигурацией

**User Story:** Как пользователь, я хочу сохранять свои учетные данные Telegram API, чтобы мне не нужно было вводить их каждый раз при запуске приложения.

#### Критерии Приемки

1. КОГДА пользователь впервые запускает приложение, GUI ДОЛЖЕН запросить ввод API_ID и API_HASH
2. КОГДА учетные данные API введены, Config_Manager ДОЛЖЕН проверить, что они являются непустыми строками
3. КОГДА предоставлены валидные учетные данные, Config_Manager ДОЛЖЕН сохранить их в локальный JSON файл конфигурации
4. КОГДА приложение запускается повторно, Config_Manager ДОЛЖЕН автоматически загрузить сохраненные учетные данные
5. Config_Manager ДОЛЖЕН хранить файл конфигурации в директории Application Support пользователя
6. GUI ДОЛЖЕН предоставлять опцию для редактирования сохраненных учетных данных API
7. Config_Manager ДОЛЖЕН шифровать чувствительные данные (API_HASH) перед сохранением на диск

### Требование 3: Аутентификация в Telegram

**User Story:** Как пользователь, я хочу аутентифицироваться в Telegram через GUI, чтобы я мог использовать приложение без взаимодействия с терминалом.

#### Критерии Приемки

1. КОГДА учетные данные API настроены, GUI ДОЛЖЕН отобразить поле ввода номера телефона
2. КОГДА номер телефона введен, Telethon_Client ДОЛЖЕН запросить код аутентификации у Telegram
3. КОГДА Telegram отправляет код, GUI ДОЛЖЕН отобразить поле ввода кода
4. КОГДА код аутентификации введен, Telethon_Client ДОЛЖЕН завершить аутентификацию
5. ЕСЛИ включена двухфакторная аутентификация, ТО GUI ДОЛЖЕН отобразить поле ввода пароля
6. КОГДА аутентификация успешна, Telethon_Client ДОЛЖЕН сохранить Session_File для будущего использования
7. КОГДА приложение запускается с валидным Session_File, Telethon_Client ДОЛЖЕН пропустить запросы аутентификации
8. ЕСЛИ аутентификация не удалась, ТО GUI ДОЛЖЕН отобразить понятное сообщение об ошибке с причиной сбоя

### Требование 4: Выбор Группы

**User Story:** Как пользователь, я хочу ввести ссылку на группу Telegram для рассылки, чтобы я мог быстро указать целевую аудиторию.

#### Критерии Приемки

1. КОГДА аутентификация выполнена, GUI ДОЛЖЕН отобразить поле ввода для ссылки на группу
2. КОГДА ссылка на группу введена, Telethon_Client ДОЛЖЕН проверить, что группа существует и доступна
3. КОГДА валидная группа выбрана, Telethon_Client ДОЛЖЕН получить список участников группы
4. ЕСЛИ у пользователя нет прав доступа к группе, ТО GUI ДОЛЖЕН отобразить сообщение об ошибке
5. КОГДА участники группы получены, GUI ДОЛЖЕН отобразить общее количество участников

### Требование 5: Встроенный Текстовый Редактор

**User Story:** Как пользователь, я хочу создавать и редактировать сообщения с форматированием прямо в приложении, чтобы я мог использовать смайлики, жирный шрифт, ссылки и другое форматирование.

#### Критерии Приемки

1. GUI ДОЛЖЕН предоставлять встроенный текстовый редактор для создания сообщений
2. Text_Editor ДОЛЖЕН поддерживать жирный шрифт, курсив и подчеркивание текста
3. Text_Editor ДОЛЖЕН поддерживать вставку смайликов и эмодзи
4. Text_Editor ДОЛЖЕН поддерживать создание встроенных ссылок в текст
5. Text_Editor ДОЛЖЕН отображать предпросмотр форматированного текста в реальном времени
6. КОГДА сообщение создано, Text_Editor ДОЛЖЕН конвертировать форматирование в HTML теги для Telegram API
7. Text_Editor ДОЛЖЕН сохранять содержимое сообщения автоматически при изменениях

### Требование 6: Отслеживание Прогресса Рассылки

**User Story:** Как пользователь, я хочу видеть прогресс рассылки в реальном времени, чтобы я знал, сколько сообщений отправлено и сколько осталось.

#### Критерии Приемки

1. КОГДА рассылка начинается, GUI ДОЛЖЕН отобразить прогресс-бар, показывающий процент завершения
2. КОГДА каждое сообщение отправлено, GUI ДОЛЖЕН обновить прогресс-бар и счетчик сообщений
3. GUI ДОЛЖЕН отображать количество отправленных, неудачных и оставшихся сообщений
4. КОГДА сообщение не удается отправить, GUI ДОЛЖЕН записать причину сбоя в область логов GUI
5. КОГДА сообщение успешно отправлено, GUI ДОЛЖЕН записать информацию о получателе
6. Progress_Tracker ДОЛЖЕН сохранять прогресс на диск после каждой успешной отправки
7. КОГДА приложение перезапускается, Progress_Tracker ДОЛЖЕН загрузить предыдущий прогресс и продолжить с последней позиции

### Требование 7: Непрерывная Работа Рассылки

**User Story:** Как пользователь, я хочу, чтобы процесс рассылки работал непрерывно без остановок, чтобы рассылка продолжалась даже когда Mac находится в режиме сна.

#### Критерии Приемки

1. КОГДА рассылка начинается, App_Bundle ДОЛЖЕН предотвратить переход Mac в режим сна
2. App_Bundle ДОЛЖЕН использовать MacOS API для поддержания активности системы во время рассылки
3. КОГДА Mac пытается перейти в режим сна, App_Bundle ДОЛЖЕН сохранить активное сетевое соединение с Telegram
4. App_Bundle ДОЛЖЕН автоматически восстанавливать соединение с Telegram при любых сетевых сбоях
5. КОГДА рассылка завершена, App_Bundle ДОЛЖЕН разрешить Mac переходить в режим сна
6. GUI ДОЛЖЕН отображать индикатор, что приложение предотвращает режим сна

### Требование 8: Пакетная Обработка и Задержки

**User Story:** Как пользователь, я хочу, чтобы приложение автоматически управляло отправкой пакетов с задержками, чтобы я избегал лимитов Telegram без ручного вмешательства.

#### Критерии Приемки

1. App_Bundle ДОЛЖЕН отправлять сообщения пакетами по 18 сообщений за пакет
2. КОГДА пакет завершен, App_Bundle ДОЛЖЕН ждать 20 часов перед началом следующего пакета
3. КОГДА ожидание между пакетами, GUI ДОЛЖЕН отображать таймер обратного отсчета, показывающий оставшееся время ожидания
4. App_Bundle ДОЛЖЕН добавлять случайные задержки от 15 до 45 секунд между отдельными сообщениями
5. КОГДА возникает ошибка FloodWait, App_Bundle ДОЛЖЕН ждать указанную длительность плюс случайные 5-10 секунд
6. КОГДА ожидание FloodWait, GUI ДОЛЖЕН отображать причину ожидания и оставшееся время

### Требование 9: Автоматическое Логирование Ошибок

**User Story:** Как пользователь, я хочу, чтобы все ошибки автоматически сохранялись в файл, чтобы я мог анализировать проблемы позже.

#### Критерии Приемки

1. КОГДА возникает UserPrivacyRestrictedError, App_Bundle ДОЛЖЕН автоматически записать ошибку в файл errors.txt
2. КОГДА возникает PeerFloodError, App_Bundle ДОЛЖЕН записать ошибку с временной меткой в errors.txt
3. КОГДА возникает ChatAdminRequiredError, App_Bundle ДОЛЖЕН записать ошибку в errors.txt
4. КОГДА возникает сетевая ошибка, Telethon_Client ДОЛЖЕН попытаться переподключиться автоматически
5. ЕСЛИ переподключение не удается после 3 попыток, ТО App_Bundle ДОЛЖЕН записать ошибку подключения в errors.txt
6. КОГДА возникает любая ошибка, App_Bundle ДОЛЖЕН записать тип ошибки, временную метку, контекст и ID пользователя в errors.txt
7. Error_Logger ДОЛЖЕН хранить файл errors.txt в директории Application Support пользователя
8. App_Bundle НЕ ДОЛЖЕН аварийно завершаться при возникновении ошибок

### Требование 10: Автоматический Расчет Задержек

**User Story:** Как пользователь, я хочу ввести дату окончания рассылки, чтобы приложение автоматически рассчитало оптимальные задержки между батчами.

#### Критерии Приемки

1. GUI ДОЛЖЕН предоставлять поле ввода для даты окончания рассылки
2. КОГДА дата окончания введена, Delay_Calculator ДОЛЖЕН рассчитать количество доступных дней до окончания
3. КОГДА количество участников группы известно, Delay_Calculator ДОЛЖЕН рассчитать количество необходимых батчей
4. Delay_Calculator ДОЛЖЕН рассчитать оптимальную задержку между батчами на основе формулы: (доступные_часы / количество_батчей)
5. GUI ДОЛЖЕН отображать рассчитанную задержку между батчами в часах
6. GUI ДОЛЖЕН отображать предполагаемую дату завершения рассылки
7. ЕСЛИ рассчитанная задержка меньше минимально безопасной (20 часов), ТО GUI ДОЛЖЕН отобразить предупреждение

### Требование 11: Сохранение Сессии

**User Story:** Как пользователь, я хочу, чтобы моя сессия Telegram сохранялась между запусками приложения, чтобы мне не нужно было аутентифицироваться каждый раз.

#### Критерии Приемки

1. КОГДА аутентификация успешна, Telethon_Client ДОЛЖЕН сохранить Session_File на диск
2. Session_File ДОЛЖЕН храниться в директории Application Support пользователя
3. КОГДА приложение запускается, Telethon_Client ДОЛЖЕН попытаться загрузить существующий Session_File
4. КОГДА существует валидный Session_File, Telethon_Client ДОЛЖЕН пропустить процесс аутентификации
5. ЕСЛИ Session_File невалиден или истек, ТО Telethon_Client ДОЛЖЕН запросить повторную аутентификацию
6. GUI ДОЛЖЕН предоставлять кнопку "Выйти" для удаления Session_File и очистки аутентификации

### Требование 12: Сохранение Прогресса

**User Story:** Как пользователь, я хочу, чтобы приложение запоминало, какие пользователи получили сообщения, чтобы я мог безопасно закрывать и открывать приложение без отправки дублирующих сообщений.

#### Критерии Приемки

1. КОГДА сообщение успешно отправлено, Progress_Tracker ДОЛЖЕН записать ID пользователя-получателя
2. Progress_Tracker ДОЛЖЕН сохранять данные прогресса в JSON файл после каждой успешной отправки
3. Progress_Tracker ДОЛЖЕН хранить файл прогресса в директории Application Support пользователя
4. КОГДА приложение запускается, Progress_Tracker ДОЛЖЕН загрузить существующие данные прогресса
5. КОГДА возобновляется рассылка, App_Bundle ДОЛЖЕН пропускать пользователей, которые уже получили сообщения
6. GUI ДОЛЖЕН отображать, сколько пользователей уже получили сообщения из предыдущих сессий
7. GUI ДОЛЖЕН предоставлять кнопку "Сбросить Прогресс" для очистки прогресса и начала заново

### Требование 13: Дизайн Пользовательского Интерфейса

**User Story:** Как пользователь, я хочу чистый и интуитивный интерфейс, чтобы я мог легко настраивать и отслеживать рассылки.

#### Критерии Приемки

1. GUI ДОЛЖЕН использовать нативные паттерны дизайна и элементы управления MacOS
2. GUI ДОЛЖЕН организовывать элементы управления в логические секции (Конфигурация, Аутентификация, Рассылка, Мониторинг)
3. GUI ДОЛЖЕН отключать элементы управления, которые не применимы к текущему состоянию приложения
4. КОГДА приложение занято, GUI ДОЛЖЕН отображать индикатор загрузки
5. GUI ДОЛЖЕН использовать соответствующую валидацию ввода и отображать ошибки валидации встроенно
6. GUI ДОЛЖЕН иметь минимальный размер окна, который отображает все элементы управления без прокрутки
7. GUI ДОЛЖЕН запоминать размер и позицию окна между запусками

### Требование 14: Безопасность Данных

**User Story:** Как пользователь, я хочу, чтобы мои учетные данные API и данные сессии хранились безопасно, чтобы неавторизованные пользователи не могли получить доступ к моему аккаунту Telegram.

#### Критерии Приемки

1. Config_Manager ДОЛЖЕН хранить API_HASH используя шифрование MacOS Keychain
2. Session_File ДОЛЖЕН иметь права доступа к файлу, установленные только для чтения/записи пользователем (600)
3. Config_Manager ДОЛЖЕН проверять права доступа к файлу при запуске и предупреждать, если они небезопасны
4. App_Bundle НЕ ДОЛЖЕН записывать учетные данные API или токены сессии в файл логов
5. КОГДА приложение удаляется, GUI ДОЛЖЕН предоставлять инструкции по удалению сохраненных учетных данных

### Требование 15: Жизненный Цикл Приложения

**User Story:** Как пользователь, я хочу, чтобы приложение корректно обрабатывало запуск и завершение, чтобы я не терял данные и не оставлял запущенные процессы.

#### Критерии Приемки

1. КОГДА приложение запускается, App_Bundle ДОЛЖЕН проверить, что все необходимые директории существуют, и создать их при необходимости
2. КОГДА приложение закрывается во время рассылки, App_Bundle ДОЛЖЕН сохранить прогресс перед выходом
3. КОГДА приложение закр��вается, Telethon_Client ДОЛЖЕН корректно отключиться от Telegram
4. ЕСЛИ приложение аварийно завершается, ТО Progress_Tracker ДОЛЖЕН восстановиться из последнего сохраненного состояния при следующем запуске
5. GUI ДОЛЖЕН отображать диалог подтверждения при закрытии во время активной рассылки
6. КОГДА пользователь подтверждает закрытие, App_Bundle ДОЛЖЕН завершить отправку текущего сообщения перед выходом
